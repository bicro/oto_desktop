<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Character Overlay</title>
    <!-- Load scripts from CDN like oto_desktop does -->
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@6.5.10/dist/browser/pixi.min.js"></script>
    <script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pixi-live2d-display-lipsyncpatch@0.5.0-ls-8/dist/cubism4.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Minimal scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.35);
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: transparent;
            cursor: grab;
        }

        body:active {
            cursor: grabbing;
        }

        #live2dCanvas {
            display: block;
            pointer-events: none;
        }

        #hitboxCanvas {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1500;
            display: none;
        }

        .hitbox-instructions {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(16px) saturate(180%);
            -webkit-backdrop-filter: blur(16px) saturate(180%);
            color: white;
            font-size: 12px;
            border-radius: 8px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            z-index: 1600;
            display: none;
        }

        /* Unified chat panel */
        .chat-panel {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            z-index: 2000;
            -webkit-app-region: no-drag;
            cursor: default;
        }

        .chat-history {
            max-height: 0;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.78);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border-radius: 16px 16px 0 0;
            display: flex;
            flex-direction: column;
            transition: max-height 0.3s ease-out;
        }

        .chat-history.visible {
            max-height: calc(100vh - 70px);
        }

        .chat-input-bar {
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.78);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border-radius: 9999px;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease, transform 0.3s ease, border-radius 0.3s ease;
        }

        .chat-history.visible ~ .chat-input-bar {
            border-radius: 0 0 24px 24px;
            opacity: 1;
            transform: translateY(0);
        }

        body.hover-enabled:hover .chat-input-bar {
            opacity: 1;
            transform: translateY(0);
        }

        body:not(.input-hidden) .chat-input-bar:focus-within {
            opacity: 1;
            transform: translateY(0);
        }

        /* Hide input bar when in character-only mode (State 1) */
        body.input-hidden .chat-input-bar {
            opacity: 0 !important;
            transform: translateY(20px) !important;
            pointer-events: none;
            transition: none !important;
        }

        /* Show input bar when chat history is visible, even in input-hidden mode */
        body.input-hidden .chat-history.visible ~ .chat-input-bar {
            opacity: 1 !important;
            transform: translateY(0) !important;
            pointer-events: auto;
            border-radius: 0 0 24px 24px;
        }

        .chat-input-bar input {
            flex: 1;
            min-width: 0;
            padding: 8px 14px;
            border: none;
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 13px;
            outline: none;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .chat-input-bar input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .chat-input-bar input:focus {
            background: rgba(255, 255, 255, 0.25);
        }

        .chat-panel.level-2 .chat-input-bar input {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.7), rgba(75, 0, 130, 0.7));
        }

        .chat-panel.level-2 .chat-input-bar input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .chat-input-bar.with-screenshot input:focus {
            border: 1px solid rgba(255, 160, 80, 0.5);
            animation: breatheGlow 4s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        .control-btn {
            width: 32px;
            height: 32px;
            min-width: 32px;
            flex-shrink: 0;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
        }

        .control-btn svg {
            display: block;
        }

        .control-btn.active {
            background: rgba(76, 175, 80, 0.8);
        }

        .control-btn[data-tooltip] {
            position: relative;
        }

        .control-btn[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            font-size: 12px;
            white-space: nowrap;
            border-radius: 6px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            pointer-events: none;
            z-index: 1000;
        }

        .control-btn[data-tooltip]:hover::after {
            opacity: 1;
            visibility: visible;
        }

        /* Scale controls for transform edit mode */
        .scale-controls {
            position: fixed;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            display: none;
            flex-direction: column;
            gap: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            -webkit-app-region: no-drag;
            z-index: 1500;
        }

        .scale-controls.visible {
            display: flex;
        }

        .scale-btn {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.3);
            color: white;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .scale-btn:hover {
            background: rgba(0, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .scale-btn:active {
            transform: scale(0.95);
        }

        .scale-separator {
            width: 24px;
            height: 1px;
            background: rgba(255, 255, 255, 0.2);
            margin: 4px 0;
        }

        .scale-btn.reset-btn {
            background: rgba(255, 150, 50, 0.3);
        }

        .scale-btn.reset-btn:hover {
            background: rgba(255, 150, 50, 0.5);
        }

        .scale-btn.confirm-btn {
            background: rgba(76, 175, 80, 0.3);
        }

        .scale-btn.confirm-btn:hover {
            background: rgba(76, 175, 80, 0.5);
        }

        .scale-btn svg {
            display: block;
        }

        .status-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 10px;
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.3s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body.hover-enabled:hover .status-indicator {
            opacity: 1;
        }

        .status-indicator.listening {
            background: rgba(76, 175, 80, 0.8);
        }

        @keyframes breatheGlow {
            0%, 100% {
                box-shadow:
                    0 0 6px rgba(255, 140, 0, 0.35),
                    0 0 12px rgba(255, 100, 0, 0.2);
            }
            50% {
                box-shadow:
                    0 0 10px rgba(255, 160, 50, 0.5),
                    0 0 20px rgba(255, 120, 0, 0.3),
                    0 0 30px rgba(255, 100, 0, 0.15);
            }
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 14px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.15);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: white;
            font-size: 14px;
            flex-shrink: 0;
            cursor: grab;
            background: #1a1a1a;
            border-radius: 16px 16px 0 0;
        }

        .history-header:active {
            cursor: grabbing;
        }

        .history-header button {
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 2px 6px;
            -webkit-app-region: no-drag;
        }

        .history-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100px;
            cursor: text;
        }

        .history-message {
            margin-bottom: 12px;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.4;
            transition: opacity 0.3s ease, max-height 0.3s ease, margin 0.3s ease, padding 0.3s ease;
            overflow: hidden;
        }

        .history-message.filtered {
            opacity: 0;
            max-height: 0;
            margin-bottom: 0;
            padding-top: 0;
            padding-bottom: 0;
            pointer-events: none;
        }

        .history-message.user {
            background: rgba(74, 158, 255, 0.2);
            color: #a8d4ff;
            margin-left: 20%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
        }

        .history-message.assistant {
            background: transparent;
            color: white;
            padding: 0;
            border-radius: 0;
        }

        .history-message.character {
            background: transparent;
            color: #39c5bb;
            font-style: italic;
            padding: 0;
            border-radius: 0;
            border-left: 3px solid #39c5bb;
            padding-left: 12px;
        }

        .history-message.focused,
        .history-message p.focused,
        .history-message h2.focused,
        .history-message h3.focused,
        .history-message h4.focused,
        .history-message pre.focused,
        .history-message ul.focused,
        .history-message ol.focused {
            outline: 2px solid rgba(255, 255, 255, 0.5);
            outline-offset: 2px;
        }

        /* Markdown in history messages */
        .history-message code {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', 'Menlo', 'Monaco', monospace;
            font-size: 13px;
        }

        .history-message pre {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 8px 0;
        }

        .history-message pre code {
            background: transparent;
            padding: 0;
            font-size: 12px;
        }

        .history-message h2, .history-message h3, .history-message h4 {
            margin: 8px 0 6px 0;
            font-weight: 600;
        }

        .history-message ul, .history-message ol {
            margin: 6px 0;
            padding-left: 18px;
        }

        .history-message li {
            margin: 3px 0;
        }

        /* Enhanced Markdown Styles */
        .md-p {
            margin: 0 0 12px 0;
            line-height: 1.6;
        }

        .md-h2 {
            font-size: 18px;
            font-weight: 600;
            margin: 16px 0 8px 0;
        }

        .md-h3 {
            font-size: 16px;
            font-weight: 600;
            margin: 14px 0 6px 0;
        }

        .md-h4 {
            font-size: 14px;
            font-weight: 600;
            margin: 12px 0 6px 0;
        }

        .md-h5 {
            font-size: 13px;
            font-weight: 600;
            margin: 10px 0 4px 0;
        }

        .code-block {
            position: relative;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            margin: 12px 0;
            overflow: hidden;
        }

        .code-block pre {
            margin: 0;
            padding: 12px;
            overflow-x: auto;
            background: transparent;
        }

        .code-block code {
            background: transparent;
            padding: 0;
            font-size: 12px;
            line-height: 1.5;
        }

        .code-lang {
            position: absolute;
            top: 4px;
            right: 8px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .inline-code {
            background: rgba(255, 150, 100, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', 'Menlo', 'Monaco', monospace;
            font-size: 13px;
        }

        .md-blockquote {
            border-left: 3px solid rgba(57, 197, 187, 0.6);
            background: rgba(57, 197, 187, 0.08);
            padding: 8px 12px;
            margin: 12px 0;
            font-style: italic;
            border-radius: 0 4px 4px 0;
        }

        .md-link {
            color: #39c5bb;
            text-decoration: none;
            transition: text-decoration 0.15s ease;
        }

        .md-link:hover {
            text-decoration: underline;
        }

        .md-hr {
            border: none;
            border-top: 1px solid rgba(255, 255, 255, 0.15);
            margin: 16px 0;
        }

        .md-table {
            border-collapse: collapse;
            width: 100%;
            margin: 12px 0;
            font-size: 13px;
        }

        .md-table th,
        .md-table td {
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 8px 12px;
            text-align: left;
        }

        .md-table th {
            background: rgba(255, 255, 255, 0.08);
            font-weight: 600;
        }

        .md-table tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.03);
        }

        .md-list {
            margin: 8px 0;
            padding-left: 0;
            list-style: none;
        }

        .md-li {
            margin: 4px 0;
            padding-left: 20px;
            position: relative;
        }

        .md-li::before {
            content: '•';
            position: absolute;
            left: 6px;
            color: rgba(255, 255, 255, 0.5);
        }

        .md-li[data-level="1"] { padding-left: 40px; }
        .md-li[data-level="2"] { padding-left: 60px; }
        .md-li[data-level="3"] { padding-left: 80px; }

        .md-li[data-ordered]::before {
            content: attr(data-index) '.';
            left: 2px;
        }

        /* Thinking animation */
        .thinking-indicator {
            display: inline;
        }
        .thinking-indicator .dot {
            opacity: 0;
            animation: dotFade 1.4s infinite;
        }
        .thinking-indicator .dot:nth-child(1) { animation-delay: 0s; }
        .thinking-indicator .dot:nth-child(2) { animation-delay: 0.2s; }
        .thinking-indicator .dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes dotFade {
            0%, 20% { opacity: 0; }
            40%, 100% { opacity: 1; }
        }

        .history-empty {
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            padding: 40px;
        }

        /* Chat tabs in header */
        .chat-tabs {
            display: flex;
            gap: 4px;
            -webkit-app-region: no-drag;
        }

        .chat-tab {
            padding: 6px 14px;
            border: none;
            border-radius: 4px;
            background: transparent;
            color: rgba(255, 255, 255, 0.5);
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            -webkit-app-region: no-drag;
        }

        .chat-tab:hover {
            background: rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.7);
        }

        .chat-tab.active {
            background: rgba(255, 255, 255, 0.12);
            color: white;
        }

        .chat-tab.tab-character.active {
            background: rgba(57, 197, 187, 0.2);
            color: #39c5bb;
        }


        /* Context menu */
        .context-menu {
            position: fixed;
            background: rgba(20, 20, 20, 0.85);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 8px;
            padding: 4px 0;
            min-width: 160px;
            z-index: 3000;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            -webkit-app-region: no-drag;
            pointer-events: auto;
        }

        .context-menu.visible {
            display: block;
        }

        .context-menu-item {
            padding: 8px 14px;
            color: white;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background 0.15s ease;
        }

        .context-menu-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .context-menu-item.danger:hover {
            background: rgba(239, 68, 68, 0.3);
        }

        .context-menu-item.active {
            background: rgba(255, 255, 255, 0.08);
        }

        .context-menu-item.active::after {
            content: '✓';
            margin-left: auto;
            opacity: 0.7;
        }

        .context-menu-separator {
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            margin: 4px 0;
        }

        .context-menu-item svg {
            width: 16px;
            height: 16px;
            opacity: 0.8;
        }

    </style>
</head>
<body class="input-hidden">
    <canvas id="hitboxCanvas"></canvas>
    <canvas id="live2dCanvas"></canvas>
    <div class="hitbox-instructions" id="hitboxInstructions">
        Click to add points. Click first point to close. ESC to cancel, ENTER to save.
    </div>

    <div class="status-indicator" id="statusIndicator"></div>


    <!-- Transform controls (visible in transform edit mode) -->
    <div class="scale-controls" id="scaleControls">
        <button class="scale-btn" id="scaleUpBtn" title="Increase Size">+</button>
        <button class="scale-btn" id="scaleDownBtn" title="Decrease Size">−</button>
        <div class="scale-separator"></div>
        <button class="scale-btn reset-btn" id="resetTransformBtn" title="Reset Transform">
            <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
        </button>
        <button class="scale-btn confirm-btn" id="confirmTransformBtn" title="Confirm & Exit">
            <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
        </button>
    </div>

    <div class="chat-panel" id="chatPanel">
        <div class="chat-history" id="historyModal">
            <div class="history-header">
                <div class="chat-tabs">
                    <button class="chat-tab tab-assistant active" data-level="0">Assistant</button>
                    <button class="chat-tab tab-character" data-level="1">Character</button>
                </div>
                <button id="closeHistoryBtn">&#x2715;</button>
            </div>
            <div class="history-content" id="historyContent"></div>
        </div>
        <div class="chat-input-bar">
            <input type="text" id="chatInput" placeholder="⌥ + Space..." autocomplete="off" />
            <button class="control-btn chat-icon" id="historyBtn" title="Chat History">
                <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                    <path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H5.2L4 17.2V4h16v12z"/>
                </svg>
            </button>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" id="menuSettings" data-action="settings">
            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
            Settings
        </div>
        <div class="context-menu-item" id="menuChat" data-action="chat">
            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H5.2L4 17.2V4h16v12z"/></svg>
            Chat History
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" id="menuTransform" data-action="edit-transform">
            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M3 5v4h2V5h4V3H5c-1.1 0-2 .9-2 2zm2 10H3v4c0 1.1.9 2 2 2h4v-2H5v-4zm14 4h-4v2h4c1.1 0 2-.9 2-2v-4h-2v4zm0-16h-4v2h4v4h2V5c0-1.1-.9-2-2-2z"/></svg>
            Edit Transform
        </div>
        <div class="context-menu-item" data-action="toggle-tracking">
            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
            <span id="trackingLabel">Disable Head Tracking</span>
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="hide">
            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>
            Hide Character
        </div>
    </div>

    <script type="module">
        const { Live2DModel } = PIXI.live2d;
        const { invoke, convertFileSrc } = window.__TAURI__.core;
        const { listen } = window.__TAURI__.event;
        const { getCurrentWindow } = window.__TAURI__.window;

        // Frontend logging helper - logs to both console and Rust log file
        async function frontendLog(level, ...args) {
            const message = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
            console[level](message);
            try {
                await invoke('log_from_frontend', { level, message });
            } catch (e) {
                // Ignore if command not available
            }
        }

        // Platform detection for keyboard shortcut tooltips and asset URL routing
        const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
        const isLinux = navigator.platform.toUpperCase().indexOf('LINUX') >= 0;
        const isWindows = !isMac && !isLinux;

        // Platform-specific placeholder text
        const defaultPlaceholder = isMac ? '⌥ + Space...' : 'Alt + Space...';

        function updateTooltips() {
            // Tooltips updated as needed
        }

        let currentBasePath = null;
        // Global cache buster - updated on each model reload to force fresh texture loading
        window.textureCacheBuster = Date.now();

        // Platform-aware asset URL resolution
        // Windows: use custom localfile:// protocol (Tauri's convertFileSrc is broken)
        // Mac/Linux: use Tauri's built-in convertFileSrc (works correctly)
        function getAssetUrl(filePath) {
            const normalized = filePath.replace(/\\/g, '/');
            if (isWindows) {
                const encoded = normalized.split('/').map(part => encodeURIComponent(part)).join('/');
                return `http://localfile.localhost/${encoded}`;
            } else {
                return convertFileSrc(normalized);
            }
        }

        // ============ Constants ============
        const MIN_ASSISTANT_TEXT_LENGTH = 80; // Minimum chars for navigable assistant blocks
        const DOUBLE_TAP_THRESHOLD_MS = 500; // Double-tap detection window
        const LEVEL_LABELS = ['Assistant', 'Character'];

        // ============ Application State ============
        /**
         * Centralized application state for the overlay UI
         * @type {Object}
         */
        const AppState = {
            /** Active context level (0=Assistant, 1=Character) */
            activeContextLevel: 0,
            /** Current focused element index in history (-1 = none) */
            historyFocusIndex: -1,
            /** Whether to include screenshot with messages */
            includeScreenshot: localStorage.getItem('screenshotEnabled') !== 'false',
            /** Timestamp of last escape key press */
            lastEscapeTime: 0,
            /** Whether head tracking is enabled */
            headTrackingEnabled: localStorage.getItem('headTrackingEnabled') === 'true',
            /** Whether assistant model supports vision */
            assistantSupportsVision: true,
            /** Whether RP model supports vision */
            rpSupportsVision: true,
            /** Shortcut toggle state: 0=hidden, 1=visible-unfocused, 2=visible-focused */
            shortcutState: 0
        };

        // ============ Asset URL Resolution ============
        function resolveAssetUrl(url) {
            if (!currentBasePath || typeof url !== 'string') return url;

            // Check if it's an asset URL that needs resolution
            const assetPrefixes = ['asset://localhost/', 'http://asset.localhost/', 'http://localfile.localhost/'];
            for (const prefix of assetPrefixes) {
                if (url.startsWith(prefix)) {
                    const pathname = url.replace(prefix, '');

                    // Skip if already properly encoded (from convertFileSrc on Mac)
                    // Encoded absolute paths start with %2F (encoded /) or drive letter like C%3A
                    if (pathname.startsWith('%2F') || /^[A-Za-z]%3A/.test(pathname)) {
                        // Already a properly formed URL, just ensure cache buster
                        if (!url.includes('?t=')) {
                            return url + '?t=' + window.textureCacheBuster;
                        }
                        return url;
                    }

                    const decoded = decodeURIComponent(pathname);

                    // Check if already an absolute path (Unix / or Windows C:/)
                    const isAbsolutePath = decoded.startsWith('/') || /^[A-Za-z]:[\\/]/.test(decoded);

                    if (!isAbsolutePath) {
                        // Relative path - prepend base path and use localfile protocol
                        const resolved = getAssetUrl(`${currentBasePath}/${decoded}`) + '?t=' + window.textureCacheBuster;
                        frontendLog('info', '[AssetResolve] Resolved relative:', decoded, '-> with base:', currentBasePath);
                        return resolved;
                    }
                    // Already absolute - convert to localfile URL
                    const resolved = getAssetUrl(decoded) + '?t=' + window.textureCacheBuster;
                    frontendLog('info', '[AssetResolve] Already absolute path:', decoded.substring(0, 50));
                    return resolved;
                }
            }

            // Handle bare asset:// URLs (relative paths from Live2D SDK)
            if (url.startsWith('asset://') && !url.startsWith('asset://localhost')) {
                const pathname = url.replace('asset://', '');
                const decoded = decodeURIComponent(pathname);
                const parentPath = currentBasePath.substring(0, currentBasePath.lastIndexOf('/'));
                // Add cache-busting to prevent texture caching
                const resolved = getAssetUrl(`${parentPath}/${decoded}`) + '?t=' + window.textureCacheBuster;
                frontendLog('info', '[AssetResolve] Resolved bare asset:', decoded, '-> parent:', parentPath);
                return resolved;
            }

            return url;
        }

        // Patch XHR
        const originalXHROpen = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function(method, url, ...args) {
            return originalXHROpen.call(this, method, resolveAssetUrl(url), ...args);
        };

        // Patch fetch
        const originalFetch = window.fetch;
        window.fetch = function(input, init) {
            return originalFetch.call(this, typeof input === 'string' ? resolveAssetUrl(input) : input, init);
        };

        // Patch Image.src
        const originalImageSrcDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src');
        Object.defineProperty(HTMLImageElement.prototype, 'src', {
            set: function(url) {
                const resolved = resolveAssetUrl(url);
                frontendLog('info', '[ImagePatch] Setting image src:', url?.substring?.(0, 80) || url, '-> resolved:', resolved?.substring?.(0, 80) || resolved);
                return originalImageSrcDescriptor.set.call(this, resolved);
            },
            get: originalImageSrcDescriptor.get,
            configurable: true,
            enumerable: true
        });

        // ============ Live2D Overlay Controller ============
        // Character rendering constants
        const CHARACTER_SCALE_MULTIPLIER = 2.0;  // Shows "bust" view (upper body focused)
        const CHARACTER_Y_POSITION = 1.02;        // Slightly below center for bust framing

        class Live2DOverlay {
            constructor() {
                this.app = null;
                this.model = null;
                this.isInitialized = false;
                this.originalModelWidth = 0;
                this.originalModelHeight = 0;
                this.characterScale = 1.0;  // User-adjustable character size within window
                this.characterOffsetX = 0;  // Horizontal offset from center
                this.characterOffsetY = 0;  // Vertical offset from default position
                this.showOutline = false;
                this.transformEditMode = false;
                this.outlineGraphics = null;
                this.dragState = null;  // null, 'move', or handle name like 'resize-br'
                this.dragStart = null;  // Starting point and values for drag
            }

            initApp() {
                if (this.app) return;

                const canvas = document.getElementById('live2dCanvas');
                this.app = new PIXI.Application({
                    view: canvas,
                    width: window.innerWidth,
                    height: window.innerHeight,
                    backgroundAlpha: 0,
                    resolution: window.devicePixelRatio || 1,
                    autoDensity: true,
                    antialias: true,
                    autoStart: false,
                });

                setInterval(() => {
                    if (this.app && this.app.ticker) {
                        this.app.ticker.update();
                    }
                }, 16);

                this.isInitialized = true;
            }

            async loadModel(modelPath, modelFileName) {
                frontendLog('info', '[Live2D] loadModel called - starting reload process');

                this.initApp();

                // Update cache buster to force fresh texture loading
                window.textureCacheBuster = Date.now();
                frontendLog('info', '[Live2D] Cache buster updated to:', window.textureCacheBuster);

                // Destroy existing model first
                if (this.model) {
                    frontendLog('info', '[Live2D] Destroying existing model');
                    this.app.stage.removeChild(this.model);
                    this.model.destroy({ children: true, texture: true, baseTexture: true });
                    this.model = null;
                }

                // Clear PIXI texture cache to force fresh loading
                frontendLog('info', '[Live2D] Clearing PIXI texture caches');
                if (PIXI.utils && PIXI.utils.TextureCache) {
                    for (const key in PIXI.utils.TextureCache) {
                        frontendLog('info', '[Live2D] Removing cached texture:', key);
                        delete PIXI.utils.TextureCache[key];
                    }
                }
                if (PIXI.utils && PIXI.utils.BaseTextureCache) {
                    for (const key in PIXI.utils.BaseTextureCache) {
                        frontendLog('info', '[Live2D] Removing cached base texture:', key);
                        PIXI.utils.BaseTextureCache[key].destroy();
                        delete PIXI.utils.BaseTextureCache[key];
                    }
                }

                try {
                    // Normalize path separators for cross-platform compatibility
                    let normalizedPath = modelPath.replace(/\\/g, '/');

                    currentBasePath = normalizedPath;
                    frontendLog('info', '[Live2D] Original model path:', modelPath);
                    frontendLog('info', '[Live2D] Normalized base path:', currentBasePath);

                    const fullPath = `${normalizedPath}/${modelFileName}`;
                    frontendLog('info', '[Live2D] Full path before URL conversion:', fullPath);

                    // Use custom localfile:// protocol (bypasses broken asset protocol on Windows)
                    const modelUrl = getAssetUrl(fullPath) + '?t=' + window.textureCacheBuster;

                    frontendLog('info', '[Live2D] Model URL after conversion:', modelUrl);

                    this.model = await Live2DModel.from(modelUrl, { autoInteract: false });
                    frontendLog('info', '[Live2D] Model.from() completed');

                    // Capture original model dimensions BEFORE any scaling
                    this.originalModelWidth = this.model.width;
                    this.originalModelHeight = this.model.height;
                    frontendLog('info', '[Live2D] Original model dimensions:', this.originalModelWidth, 'x', this.originalModelHeight);

                    this.app.stage.addChild(this.model);
                    this.resizeModel();

                    frontendLog('info', '[Live2D] Model loaded successfully!');
                    return { width: this.model.width, height: this.model.height };
                } catch (error) {
                    frontendLog('error', '[Live2D] Load failed:', error);
                    currentBasePath = null;
                    throw error;
                }
            }

            // Single source of truth for model scale/position calculation
            updateModelTransform(canvasWidth, canvasHeight) {
                if (!this.model || !this.originalModelWidth || !this.originalModelHeight) return;

                // Calculate base scale to fit model in canvas
                const baseScaleX = canvasWidth / this.originalModelWidth;
                const baseScaleY = canvasHeight / this.originalModelHeight;
                const baseScale = Math.min(baseScaleX, baseScaleY);

                // Apply bust multiplier and user-adjustable character scale
                const finalScale = baseScale * CHARACTER_SCALE_MULTIPLIER * this.characterScale;
                this.model.scale.set(finalScale);

                // Position model (centered with user offset, slightly below for bust framing)
                this.model.x = canvasWidth / 2 + this.characterOffsetX;
                this.model.y = canvasHeight * CHARACTER_Y_POSITION + this.characterOffsetY;
                this.model.anchor.set(0.5, 0.5);

                // Update outline if visible
                this.renderOutline();
            }

            // Update model for current window dimensions
            resizeModel() {
                this.updateModelTransform(window.innerWidth, window.innerHeight);
            }

            // Resize PIXI canvas and update model
            resizeCanvas(width, height) {
                if (!this.app || !this.app.renderer) return;
                this.app.renderer.resize(width, height);
                this.updateModelTransform(width, height);
            }

            // Initialize PIXI Graphics for outline rendering
            initOutlineGraphics() {
                if (!this.app || this.outlineGraphics) return;
                this.outlineGraphics = new PIXI.Graphics();
                this.app.stage.addChild(this.outlineGraphics);
            }

            // Render outline around the overlay window bounds
            renderOutline() {
                if (!this.outlineGraphics) {
                    this.initOutlineGraphics();
                }
                if (!this.outlineGraphics) return;

                this.outlineGraphics.clear();

                const w = window.innerWidth;
                const h = window.innerHeight;

                // Draw cyan outline around canvas/window bounds (if outline enabled or in edit mode)
                if (this.showOutline || this.transformEditMode) {
                    const padding = 2;
                    this.outlineGraphics.lineStyle(2, 0x00FFFF, 0.8);
                    this.outlineGraphics.drawRect(padding, padding, w - padding * 2, h - padding * 2);
                }

                // Draw resize handles and position indicator when in edit mode
                if (this.transformEditMode) {
                    const handleSize = 12;

                    // Draw resize handles at corners and midpoints
                    this.outlineGraphics.beginFill(0x00FFFF, 1);
                    // Corners
                    this.drawHandle(0, 0, handleSize);       // TopLeft
                    this.drawHandle(w, 0, handleSize);       // TopRight
                    this.drawHandle(0, h, handleSize);       // BottomLeft
                    this.drawHandle(w, h, handleSize);       // BottomRight
                    // Midpoints
                    this.drawHandle(w / 2, 0, handleSize);   // Top
                    this.drawHandle(w / 2, h, handleSize);   // Bottom
                    this.drawHandle(0, h / 2, handleSize);   // Left
                    this.drawHandle(w, h / 2, handleSize);   // Right
                    this.outlineGraphics.endFill();

                    // Draw anchor point (orange crosshair at model position)
                    if (this.model) {
                        const ax = this.model.x;
                        const ay = this.model.y;
                        this.outlineGraphics.lineStyle(2, 0xFF6600, 1);
                        this.outlineGraphics.moveTo(ax - 12, ay);
                        this.outlineGraphics.lineTo(ax + 12, ay);
                        this.outlineGraphics.moveTo(ax, ay - 12);
                        this.outlineGraphics.lineTo(ax, ay + 12);
                        this.outlineGraphics.drawCircle(ax, ay, 6);
                    }
                }
            }

            // Helper to draw a square handle
            drawHandle(x, y, size) {
                this.outlineGraphics.drawRect(x - size / 2, y - size / 2, size, size);
            }

            // Setup mouse event handlers for transform editing
            setupTransformHandlers() {
                const canvas = document.getElementById('live2dCanvas');
                canvas.addEventListener('mousedown', (e) => this.onTransformMouseDown(e));
                canvas.addEventListener('mousemove', (e) => this.onTransformMouseMove(e));
                canvas.addEventListener('mouseup', (e) => this.onTransformMouseUp(e));
                canvas.addEventListener('mouseleave', (e) => this.onTransformMouseUp(e));
            }

            // Get which window resize handle (if any) is at the given point
            getWindowHandleAtPoint(x, y) {
                const handleSize = 16;  // Hit area for handles
                const w = window.innerWidth;
                const h = window.innerHeight;

                // Window resize handles at corners and edges
                const handles = [
                    { name: 'TopLeft', x: 0, y: 0 },
                    { name: 'TopRight', x: w, y: 0 },
                    { name: 'BottomLeft', x: 0, y: h },
                    { name: 'BottomRight', x: w, y: h },
                    { name: 'Top', x: w / 2, y: 0 },
                    { name: 'Bottom', x: w / 2, y: h },
                    { name: 'Left', x: 0, y: h / 2 },
                    { name: 'Right', x: w, y: h / 2 },
                ];

                for (const handle of handles) {
                    if (Math.abs(x - handle.x) < handleSize && Math.abs(y - handle.y) < handleSize) {
                        return handle.name;
                    }
                }
                return null;
            }

            async onTransformMouseDown(e) {
                if (!this.transformEditMode || !this.model) return;

                const x = e.clientX;
                const y = e.clientY;

                // Check if clicking on a window resize handle
                const resizeHandle = this.getWindowHandleAtPoint(x, y);
                if (resizeHandle) {
                    // Start window resize via Tauri
                    e.preventDefault();
                    const win = getCurrentWindow();
                    await win.startResizing(resizeHandle);
                    return;
                }

                // Otherwise, drag to move character position
                this.dragState = 'move';
                this.dragStart = {
                    x, y,
                    offsetX: this.characterOffsetX,
                    offsetY: this.characterOffsetY
                };
                e.preventDefault();
            }

            onTransformMouseMove(e) {
                if (!this.dragState || !this.transformEditMode) return;

                const x = e.clientX;
                const y = e.clientY;
                const dx = x - this.dragStart.x;
                const dy = y - this.dragStart.y;

                // Move the character
                this.characterOffsetX = this.dragStart.offsetX + dx;
                this.characterOffsetY = this.dragStart.offsetY + dy;

                this.resizeModel();
            }

            async onTransformMouseUp(e) {
                if (this.dragState === 'move') {
                    // Save config after drag ends
                    try {
                        await invoke('save_transform_config', {
                            scale: this.characterScale,
                            offsetX: this.characterOffsetX,
                            offsetY: this.characterOffsetY
                        });
                        console.log('[Transform] Saved config after drag');
                    } catch (err) {
                        console.error('[Transform] Failed to save:', err);
                    }
                }
                this.dragState = null;
                this.dragStart = null;
            }

            getCoreModel() {
                return this.model?.internalModel?.coreModel;
            }

            setParameter(paramId, value) {
                const coreModel = this.getCoreModel();
                if (coreModel) {
                    coreModel.setParameterValueById(paramId, Number(value));
                }
            }
        }

        const live2dOverlay = new Live2DOverlay();
        window.live2dOverlay = live2dOverlay;

        // ============ Auto-load model on window open ============
        let modelLoadInProgress = false;

        async function autoLoadModel() {
            if (modelLoadInProgress) {
                frontendLog('info', '[Overlay] Model load already in progress, skipping');
                return;
            }
            modelLoadInProgress = true;
            frontendLog('info', '[Overlay] autoLoadModel started');

            try {
                // Get model config for dynamic model loading
                frontendLog('info', '[Overlay] Fetching model config...');
                const config = await invoke('get_model_config');
                frontendLog('info', '[Overlay] Model config:', config);

                frontendLog('info', '[Overlay] Fetching models path...');
                const modelsPath = await invoke('get_paths');
                frontendLog('info', '[Overlay] Models path:', modelsPath);

                const modelPath = `${modelsPath}/${config.folder}`;
                const modelFileName = config.model_file;

                frontendLog('info', '[Overlay] Full model path:', modelPath);
                frontendLog('info', '[Overlay] Model filename:', modelFileName);
                frontendLog('info', '[Overlay] Loading model...');
                await live2dOverlay.loadModel(modelPath, modelFileName);
                frontendLog('info', '[Overlay] Model loaded successfully!');

                // Load saved transform config
                try {
                    const transformConfig = await invoke('load_transform_config');
                    live2dOverlay.characterScale = transformConfig.scale;
                    live2dOverlay.characterOffsetX = transformConfig.offset_x;
                    live2dOverlay.characterOffsetY = transformConfig.offset_y;
                    live2dOverlay.resizeModel();
                    frontendLog('info', '[Overlay] Loaded transform config:', transformConfig);
                } catch (e) {
                    frontendLog('info', '[Overlay] No saved transform config, using defaults');
                }

                // Start device listening for head tracking
                await invoke('start_device_listening');
                frontendLog('info', '[Overlay] autoLoadModel completed successfully');
            } catch (error) {
                frontendLog('error', '[Overlay] Failed to auto-load model:', error);
            } finally {
                modelLoadInProgress = false;
                frontendLog('info', '[Overlay] modelLoadInProgress reset to false');
            }
        }

        // ============ Tauri Event Handlers ============
        listen('device-changed', async (event) => {
            // Skip if head tracking is disabled
            if (!AppState.headTrackingEnabled) return;

            const { kind, value } = event.payload;

            if (kind === 'MouseMove') {
                const { x, y } = value;
                const screenWidth = window.screen.width;
                const screenHeight = window.screen.height;

                // Head tracking
                const angleX = ((x / screenWidth) - 0.5) * 60;
                const angleY = ((y / screenHeight) - 0.5) * -60;

                live2dOverlay.setParameter('ParamAngleX', angleX);
                live2dOverlay.setParameter('ParamAngleY', angleY);
                live2dOverlay.setParameter('ParamBodyAngleX', angleX * 0.3);
            }
        });

        // Listen for head tracking toggle from settings
        listen('head-tracking-changed', (event) => {
            AppState.headTrackingEnabled = event.payload.enabled;
            localStorage.setItem('headTrackingEnabled', event.payload.enabled);
            // Reset head position when disabled
            if (!event.payload.enabled) {
                live2dOverlay.setParameter('ParamAngleX', 0);
                live2dOverlay.setParameter('ParamAngleY', 0);
                live2dOverlay.setParameter('ParamBodyAngleX', 0);
            }
        });

        // Listen for transform edit toggle from settings
        listen('toggle-transform-edit', (event) => {
            live2dOverlay.transformEditMode = event.payload.enabled;

            // Enable pointer events on canvas so drag handlers work
            const canvas = document.getElementById('live2dCanvas');
            canvas.style.pointerEvents = event.payload.enabled ? 'auto' : 'none';

            // Show/hide scale controls
            const scaleControls = document.getElementById('scaleControls');
            scaleControls.classList.toggle('visible', event.payload.enabled);

            live2dOverlay.renderOutline();
        });

        // Helper to save transform config
        async function saveTransformConfig() {
            try {
                await invoke('save_transform_config', {
                    scale: live2dOverlay.characterScale,
                    offsetX: live2dOverlay.characterOffsetX,
                    offsetY: live2dOverlay.characterOffsetY
                });
                console.log('[Transform] Saved config');
            } catch (e) {
                console.error('[Transform] Failed to save:', e);
            }
        }

        // Scale button handlers
        document.getElementById('scaleUpBtn').addEventListener('click', async () => {
            live2dOverlay.characterScale = Math.min(2.0, live2dOverlay.characterScale + 0.1);
            live2dOverlay.resizeModel();
            await saveTransformConfig();
        });

        document.getElementById('scaleDownBtn').addEventListener('click', async () => {
            live2dOverlay.characterScale = Math.max(0.25, live2dOverlay.characterScale - 0.1);
            live2dOverlay.resizeModel();
            await saveTransformConfig();
        });

        // Reset transform button - reset to defaults
        document.getElementById('resetTransformBtn').addEventListener('click', async () => {
            live2dOverlay.characterScale = 1.0;
            live2dOverlay.characterOffsetX = 0;
            live2dOverlay.characterOffsetY = 0;
            live2dOverlay.resizeModel();
            await saveTransformConfig();
        });

        // Confirm transform button - save and exit edit mode
        document.getElementById('confirmTransformBtn').addEventListener('click', async () => {
            await saveTransformConfig();

            // Exit transform edit mode
            live2dOverlay.transformEditMode = false;

            // Disable pointer events on canvas
            const canvas = document.getElementById('live2dCanvas');
            canvas.style.pointerEvents = 'none';

            // Hide scale controls
            const scaleControls = document.getElementById('scaleControls');
            scaleControls.classList.remove('visible');

            live2dOverlay.renderOutline();
        });

        // Listen for transform reset from settings
        listen('reset-character-transform', async () => {
            live2dOverlay.characterScale = 1.5;
            live2dOverlay.characterOffsetX = 15.0;
            live2dOverlay.characterOffsetY = 109.0;
            live2dOverlay.resizeModel();
            await saveTransformConfig();
        });

        // Setup transform mouse handlers
        live2dOverlay.setupTransformHandlers();

        // ============ Hitbox Editor ============
        const hitboxCanvas = document.getElementById('hitboxCanvas');
        const hitboxCtx = hitboxCanvas.getContext('2d');
        const hitboxInstructions = document.getElementById('hitboxInstructions');

        let hitboxEditMode = false;
        let hitboxPreviewMode = false;
        let hitboxPoints = [];        // [{x: 0-1, y: 0-1}, ...] normalized
        let isPolygonClosed = false;

        function normalizePoint(x, y) {
            return {
                x: x / window.innerWidth,
                y: y / window.innerHeight
            };
        }

        function denormalizePoint(point) {
            return {
                x: point.x * window.innerWidth,
                y: point.y * window.innerHeight
            };
        }

        function isPointInPolygon(x, y, polygon) {
            if (polygon.length < 3) return false;
            const testX = x / window.innerWidth;
            const testY = y / window.innerHeight;
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                const intersect = ((yi > testY) !== (yj > testY)) &&
                    (testX < (xj - xi) * (testY - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function resizeHitboxCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const width = window.innerWidth;
            const height = window.innerHeight;

            // Set display size (CSS pixels)
            hitboxCanvas.style.width = width + 'px';
            hitboxCanvas.style.height = height + 'px';

            // Set actual canvas buffer size (device pixels)
            hitboxCanvas.width = width * dpr;
            hitboxCanvas.height = height * dpr;

            // Scale context for retina (setting canvas.width resets transforms)
            hitboxCtx.scale(dpr, dpr);
        }

        function renderHitboxOverlay() {
            hitboxCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);

            if (hitboxPoints.length === 0) return;

            // Draw filled polygon with transparency
            hitboxCtx.fillStyle = 'rgba(76, 175, 80, 0.2)';
            hitboxCtx.strokeStyle = 'rgba(76, 175, 80, 0.8)';
            hitboxCtx.lineWidth = 2;

            hitboxCtx.beginPath();
            const firstPoint = denormalizePoint(hitboxPoints[0]);
            hitboxCtx.moveTo(firstPoint.x, firstPoint.y);

            for (let i = 1; i < hitboxPoints.length; i++) {
                const point = denormalizePoint(hitboxPoints[i]);
                hitboxCtx.lineTo(point.x, point.y);
            }

            if (isPolygonClosed || hitboxPreviewMode) {
                hitboxCtx.closePath();
                hitboxCtx.fill();
            }
            hitboxCtx.stroke();

            // Draw point handles (only in edit mode, not preview mode)
            if (hitboxEditMode && !hitboxPreviewMode) {
                hitboxPoints.forEach((point, index) => {
                    const p = denormalizePoint(point);
                    hitboxCtx.beginPath();
                    hitboxCtx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                    hitboxCtx.fillStyle = index === 0 ? '#ff5722' : '#4CAF50';
                    hitboxCtx.fill();
                    hitboxCtx.strokeStyle = 'white';
                    hitboxCtx.lineWidth = 2;
                    hitboxCtx.stroke();
                });
            }
        }

        function enterHitboxEditMode() {
            hitboxEditMode = true;
            hitboxPreviewMode = false; // Turn off preview when entering edit mode
            hitboxPoints = [];
            isPolygonClosed = false;

            resizeHitboxCanvas();
            hitboxCanvas.style.display = 'block';
            hitboxInstructions.style.display = 'block';
            document.body.style.cursor = 'crosshair';

            renderHitboxOverlay();
        }

        async function exitHitboxEditMode(save) {
            hitboxEditMode = false;

            // Hide visual immediately
            hitboxCtx.clearRect(0, 0, hitboxCanvas.width, hitboxCanvas.height);
            hitboxCanvas.style.display = 'none';
            hitboxInstructions.style.display = 'none';
            document.body.style.cursor = 'grab';

            // Save hitbox points if requested (but don't activate click-through)
            if (save && hitboxPoints.length >= 3) {
                isPolygonClosed = true;
                try {
                    await invoke('save_hitbox', { points: hitboxPoints });
                    console.log('[Hitbox] Saved', hitboxPoints.length, 'points');
                } catch (e) {
                    console.error('[Hitbox] Failed to save:', e);
                }
            }
        }

        function handleHitboxClick(event) {
            if (!hitboxEditMode) return;

            const x = event.clientX;
            const y = event.clientY;

            // Check if clicking near first point to close polygon
            if (hitboxPoints.length >= 3) {
                const firstPoint = denormalizePoint(hitboxPoints[0]);
                const distance = Math.sqrt(Math.pow(x - firstPoint.x, 2) + Math.pow(y - firstPoint.y, 2));
                if (distance < 15) {
                    // Close polygon and exit edit mode
                    exitHitboxEditMode(true);
                    return;
                }
            }

            // Add new point
            hitboxPoints.push(normalizePoint(x, y));
            renderHitboxOverlay();
        }

        async function loadSavedHitbox() {
            try {
                const data = await invoke('load_hitbox');
                if (data && data.points && data.points.length >= 3) {
                    hitboxPoints = data.points;
                    isPolygonClosed = true;
                    console.log('[Hitbox] Loaded saved hitbox with', hitboxPoints.length, 'points');
                } else {
                    hitboxPoints = [];
                    isPolygonClosed = false;
                }
            } catch (error) {
                console.error('[Hitbox] Failed to load:', error);
                hitboxPoints = [];
                isPolygonClosed = false;
            }
        }

        // Keyboard shortcuts for hitbox editing
        document.addEventListener('keydown', (e) => {
            if (!hitboxEditMode) return;

            if (e.key === 'Escape') {
                exitHitboxEditMode(false);
            } else if (e.key === 'Enter' && hitboxPoints.length >= 3) {
                exitHitboxEditMode(true);
            } else if ((e.key === 'Backspace' || e.key === 'Delete') && hitboxPoints.length > 0) {
                hitboxPoints.pop();
                renderHitboxOverlay();
            }
        });

        // Right-click context menu
        const contextMenu = document.getElementById('contextMenu');

        async function showContextMenu(x, y) {
            // Update tracking label based on current state
            const trackingLabel = document.getElementById('trackingLabel');
            trackingLabel.textContent = AppState.headTrackingEnabled ? 'Disable Head Tracking' : 'Enable Head Tracking';

            // Update active states for toggles
            const menuSettings = document.getElementById('menuSettings');
            const menuChat = document.getElementById('menuChat');

            // Check if settings window is visible
            try {
                const isSettingsVisible = await invoke('is_main_window_visible');
                menuSettings.classList.toggle('active', isSettingsVisible);
            } catch (e) {
                menuSettings.classList.remove('active');
            }

            // Check if chat history is visible
            const isChatVisible = historyModal.classList.contains('visible');
            menuChat.classList.toggle('active', isChatVisible);

            // Check if transform edit mode is active
            const menuTransform = document.getElementById('menuTransform');
            menuTransform.classList.toggle('active', live2dOverlay.transformEditMode);

            // Position menu, keeping it within viewport
            const menuWidth = 160;
            const menuHeight = contextMenu.offsetHeight || 250;
            const maxX = window.innerWidth - menuWidth - 5;
            const maxY = window.innerHeight - menuHeight - 5;

            contextMenu.style.left = Math.min(x, maxX) + 'px';
            contextMenu.style.top = Math.min(y, maxY) + 'px';
            contextMenu.classList.add('visible');
        }

        function hideContextMenu() {
            contextMenu.classList.remove('visible');
        }

        // Handle context menu item clicks
        contextMenu.addEventListener('click', async (e) => {
            const item = e.target.closest('.context-menu-item');
            if (!item) return;

            const action = item.dataset.action;
            hideContextMenu();

            switch (action) {
                case 'settings':
                    await invoke('toggle_main_window');
                    break;
                case 'chat':
                    // Toggle chat history
                    if (historyModal.classList.contains('visible')) {
                        hideHistoryModal();
                    } else {
                        showHistoryModal();
                    }
                    break;
                case 'edit-transform':
                    // Toggle transform edit mode
                    live2dOverlay.transformEditMode = !live2dOverlay.transformEditMode;

                    // Enable pointer events on canvas so drag handlers work
                    const canvas = document.getElementById('live2dCanvas');
                    canvas.style.pointerEvents = live2dOverlay.transformEditMode ? 'auto' : 'none';

                    // Show/hide scale controls
                    const scaleControls = document.getElementById('scaleControls');
                    scaleControls.classList.toggle('visible', live2dOverlay.transformEditMode);

                    live2dOverlay.renderOutline();
                    break;
                case 'toggle-tracking':
                    AppState.headTrackingEnabled = !AppState.headTrackingEnabled;
                    localStorage.setItem('headTrackingEnabled', AppState.headTrackingEnabled);
                    if (!AppState.headTrackingEnabled) {
                        live2dOverlay.setParameter('ParamAngleX', 0);
                        live2dOverlay.setParameter('ParamAngleY', 0);
                        live2dOverlay.setParameter('ParamBodyAngleX', 0);
                    }
                    break;
                case 'hide':
                    await invoke('hide_overlay');
                    break;
            }
        });

        // Hide context menu on click outside
        document.addEventListener('click', (e) => {
            if (!contextMenu.contains(e.target)) {
                hideContextMenu();
            }
        });

        // Hide context menu on escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && contextMenu.classList.contains('visible')) {
                hideContextMenu();
                e.stopPropagation();
            }
        });

        // Hide context menu when window loses focus (clicking outside the app)
        window.addEventListener('blur', () => {
            hideContextMenu();
        });

        document.addEventListener('contextmenu', async (e) => {
            // Hitbox edit mode: undo last point
            if (hitboxEditMode) {
                e.preventDefault();
                if (hitboxPoints.length > 0) {
                    hitboxPoints.pop();
                    renderHitboxOverlay();
                }
                return;
            }

            // Don't show context menu on chat panel
            if (e.target.closest('.chat-panel')) {
                return;
            }

            // If right-clicking on the context menu itself, just close it
            if (e.target.closest('.context-menu')) {
                e.preventDefault();
                hideContextMenu();
                return;
            }

            // Show custom context menu
            e.preventDefault();
            await showContextMenu(e.clientX, e.clientY);
        });

        // Handle window resize - rescale Live2D canvas and hitbox canvas
        window.addEventListener('resize', () => {
            // Resize Live2D canvas to match window
            live2dOverlay.resizeCanvas(window.innerWidth, window.innerHeight);

            // Resize hitbox canvas if in edit/preview mode
            if (hitboxEditMode || hitboxPreviewMode) {
                resizeHitboxCanvas();
                renderHitboxOverlay();
            }
        });


        // ============ Control Buttons ============

        // Listen for hitbox edit event from settings page
        listen('enter-hitbox-edit', () => {
            if (!hitboxEditMode) {
                enterHitboxEditMode();
            }
        });

        // Listen for hitbox preview toggle from settings page
        listen('toggle-hitbox-preview', async () => {
            if (hitboxEditMode) return; // Don't toggle preview while editing

            // Load hitbox if not already loaded
            if (hitboxPoints.length < 3) {
                await loadSavedHitbox();
            }

            hitboxPreviewMode = !hitboxPreviewMode;

            if (hitboxPreviewMode && hitboxPoints.length >= 3) {
                isPolygonClosed = true;
                hitboxCanvas.style.display = 'block';
                resizeHitboxCanvas();
                renderHitboxOverlay();
                console.log('[Hitbox] Preview ON -', hitboxPoints.length, 'points');
            } else {
                hitboxPreviewMode = false;
                hitboxCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
                hitboxCanvas.style.display = 'none';
                console.log('[Hitbox] Preview OFF');
            }
        });

        // Track clicks for double-click detection
        let lastClickTime = 0;
        let dragTimeout = null;

        document.body.addEventListener('mousedown', async (event) => {
            // Hide context menu on any click outside of it
            if (!event.target.closest('.context-menu')) {
                hideContextMenu();
            }

            // Handle hitbox editing clicks
            if (hitboxEditMode) {
                if (!event.target.closest('.chat-panel')) {
                    handleHitboxClick(event);
                }
                return;
            }

            // Don't interfere with UI elements
            if (event.target.closest('.chat-panel')) return;
            if (event.target.closest('.textbox-container')) return;
            if (event.target.closest('.context-menu')) return;

            // Only drag if inside polygon (or no polygon defined)
            // AND not in transform edit mode
            if (!live2dOverlay.transformEditMode &&
                (hitboxPoints.length < 3 || isPointInPolygon(event.clientX, event.clientY, hitboxPoints))) {
                const now = Date.now();
                const isDoubleClick = (now - lastClickTime) < 300;
                lastClickTime = now;

                // If this might be a double-click, delay dragging
                if (isDoubleClick) {
                    // Don't start dragging - let dblclick handler take over
                    return;
                }

                // Delay drag start to allow double-click detection
                const win = getCurrentWindow();
                dragTimeout = setTimeout(() => {
                    win.startDragging();
                }, 150);
            }
        });

        // Cancel pending drag on mouseup (for quick clicks)
        document.body.addEventListener('mouseup', () => {
            if (dragTimeout) {
                clearTimeout(dragTimeout);
                dragTimeout = null;
            }
        });

        // Double-click character to focus chat input
        document.body.addEventListener('dblclick', (event) => {
            // Cancel any pending drag
            if (dragTimeout) {
                clearTimeout(dragTimeout);
                dragTimeout = null;
            }

            // Don't interfere with hitbox editing
            if (hitboxEditMode) return;

            // Don't interfere with UI elements
            if (event.target.closest('.chat-panel')) return;
            if (event.target.closest('.textbox-container')) return;
            if (event.target.closest('.context-menu')) return;

            // Only trigger if inside polygon (or no polygon defined)
            if (hitboxPoints.length < 3 || isPointInPolygon(event.clientX, event.clientY, hitboxPoints)) {
                // Transition to focused state (State 2)
                AppState.shortcutState = 2;
                document.body.classList.remove('input-hidden');
                document.body.classList.add('hover-enabled');
                chatInput.focus();
            }
        });

        // ============ Chat Input ============
        const chatInput = document.getElementById('chatInput');
        const chatPanel = document.getElementById('chatPanel');
        const chatInputBar = document.querySelector('.chat-input-bar');
        const historyModal = document.getElementById('historyModal');
        const historyContent = document.getElementById('historyContent');

        // Set platform-specific placeholder on init
        chatInput.placeholder = defaultPlaceholder;

        // Sync shortcut state with focus/blur events
        chatInput.addEventListener('focus', () => {
            if (AppState.shortcutState === 1) {
                AppState.shortcutState = 2;
                document.body.classList.remove('input-hidden');
            }
        });
        chatInput.addEventListener('blur', () => {
            if (AppState.shortcutState === 2) {
                AppState.shortcutState = 1;
                // Temporarily disable hover to show character-only state
                document.body.classList.remove('hover-enabled');
                setTimeout(() => {
                    if (AppState.shortcutState === 1) {
                        document.body.classList.add('hover-enabled');
                    }
                }, 300);
            }
        });

        // NOTE: State variables are now in AppState object at top of file

        /**
         * Gets navigable elements in history based on active context levels
         * @returns {HTMLElement[]} Array of navigable DOM elements
         */
        function getNavigableElements() {
            const elements = [];
            historyContent.querySelectorAll('.history-message').forEach(msg => {
                // Skip messages that are filtered out
                if (msg.classList.contains('filtered')) {
                    return;
                }

                if (msg.classList.contains('assistant')) {
                    // Add block-level children, skip short one-liners
                    msg.querySelectorAll('p, h2, h3, h4, pre, ul, ol').forEach(el => {
                        if (el.textContent.trim().length >= MIN_ASSISTANT_TEXT_LENGTH) {
                            elements.push(el);
                        }
                    });
                } else {
                    // User/character messages always included
                    elements.push(msg);
                }
            });
            return elements;
        }

        /**
         * Navigates through history elements vertically
         * @param {'up'|'down'} direction - Navigation direction
         * @returns {boolean} True if navigation occurred, false if should close modal
         */
        function navigateHistoryVertical(direction) {
            const elements = getNavigableElements();
            if (elements.length === 0) return true;

            // Remove focus from current element
            if (AppState.historyFocusIndex >= 0 && AppState.historyFocusIndex < elements.length) {
                elements[AppState.historyFocusIndex].classList.remove('focused');
            }

            if (direction === 'up') {
                if (AppState.historyFocusIndex <= 0) {
                    AppState.historyFocusIndex = elements.length - 1; // Wrap to bottom
                } else {
                    AppState.historyFocusIndex--;
                }
            } else {
                if (AppState.historyFocusIndex >= elements.length - 1) {
                    return false; // Signal to close modal
                } else {
                    AppState.historyFocusIndex++;
                }
            }

            // Focus new element
            elements[AppState.historyFocusIndex].classList.add('focused');
            elements[AppState.historyFocusIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
            return true;
        }

        /**
         * Changes the history filter level using arrow keys
         * @param {'left'|'right'} direction - Direction to change level
         */
        function changeHistoryLevel(direction) {
            // Switch between tabs: 0 (Assistant) <-> 1 (Character)
            let newLevel;
            if (direction === 'right' && AppState.activeContextLevel === 0) {
                newLevel = 1;
            } else if (direction === 'left' && AppState.activeContextLevel === 1) {
                newLevel = 0;
            } else {
                return; // Already at the edge
            }

            // Check if new model supports vision
            const newSupportsVision = newLevel === 0
                ? AppState.assistantSupportsVision
                : AppState.rpSupportsVision;

            // If screenshot is enabled but new model doesn't support vision, disable it
            if (AppState.includeScreenshot && !newSupportsVision) {
                AppState.includeScreenshot = false;
                localStorage.setItem('screenshotEnabled', 'false');
                updateStatus("Model doesn't support images - screenshot disabled", 'listening');
                setTimeout(() => updateStatus('', ''), 2000);
            }

            AppState.activeContextLevel = newLevel;
            AppState.historyFocusIndex = -1;
            loadChatHistory().then(() => {
                applyHistoryFilter();
                chatInput.focus();
                updateScreenshotVisual();
            });
        }

        /**
         * Determines if a message should be filtered based on active context level
         * @param {string} role - Message role (user/assistant/character)
         * @param {number} msgContextLevel - Message's context level
         * @returns {boolean} True if message should be hidden
         */
        function shouldFilterMessage(role, msgContextLevel) {
            const activeLevel = AppState.activeContextLevel;

            // User messages: show if their context level matches active
            if (role === 'user') {
                return msgContextLevel !== activeLevel;
            }

            // Assistant messages: show if level 0 is active
            if (role === 'assistant') {
                return activeLevel !== 0;
            }

            // Character messages: only show if Character tab (level 1) is active
            if (role === 'character') {
                return activeLevel !== 1;
            }

            return false;
        }

        /**
         * Applies message visibility filtering based on current level
         */
        function filterMessagesByLevel() {
            historyContent.querySelectorAll('.history-message').forEach(msg => {
                const role = msg.classList.contains('user') ? 'user' :
                             msg.classList.contains('assistant') ? 'assistant' :
                             msg.classList.contains('character') ? 'character' : 'unknown';
                const msgContextLevel = parseInt(msg.getAttribute('data-context-level') || '0', 10);
                msg.classList.toggle('filtered', shouldFilterMessage(role, msgContextLevel));
            });
        }

        /**
         * Updates the input field placeholder and state based on active context levels
         */
        function updateInputStateForLevel() {
            chatInput.placeholder = defaultPlaceholder;
            chatInput.disabled = false;
        }

        /**
         * Main function to apply history filter - orchestrates filtering, UI updates, and scroll
         */
        function applyHistoryFilter() {
            // Clear current focus
            historyContent.querySelectorAll('.focused').forEach(el => el.classList.remove('focused'));

            // Apply filtering
            filterMessagesByLevel();

            // Update UI elements
            updateLevelIndicator();
            updateInputStateForLevel();
            updateScreenshotVisual();

            // Scroll to bottom after filter applied (force since user changed filter)
            scrollHistoryToBottom(true);
        }

        // Track if user is near bottom of scroll (for smart auto-scroll)
        let userNearBottom = true;
        const SCROLL_THRESHOLD = 50; // pixels from bottom to consider "at bottom"

        // Track the user message element for the current streaming response
        let currentUserMessageElement = null;

        historyContent.addEventListener('scroll', () => {
            const { scrollTop, scrollHeight, clientHeight } = historyContent;
            userNearBottom = scrollHeight - scrollTop - clientHeight < SCROLL_THRESHOLD;
        });

        // Helper function to scroll history to bottom (only if user is near bottom)
        // When streaming, stops scrolling once the user's message reaches the top
        function scrollHistoryToBottom(force = false) {
            if (force || userNearBottom) {
                // If we have a user message to keep visible during streaming
                if (currentUserMessageElement) {
                    const containerRect = historyContent.getBoundingClientRect();
                    const messageRect = currentUserMessageElement.getBoundingClientRect();

                    // Calculate how far the user message is from the top of the container
                    const messageTopRelativeToContainer = messageRect.top - containerRect.top;

                    // If the message is still visible (not at the very top yet), we can scroll more
                    // Allow scrolling until the message is near the top (with a small margin)
                    const topMargin = 10;

                    if (messageTopRelativeToContainer > topMargin) {
                        // Message still has room to move up - scroll to bottom
                        historyContent.scrollTop = historyContent.scrollHeight;
                    }
                    // else: message is at or past the top - don't scroll further
                } else {
                    // No user message tracking - scroll normally to bottom
                    historyContent.scrollTop = historyContent.scrollHeight;
                }
                userNearBottom = true;
            }
        }

        /**
         * Updates the active state of chat tabs
         */
        function updateLevelIndicator() {
            document.querySelectorAll('.chat-tab').forEach(tab => {
                const level = parseInt(tab.getAttribute('data-level'), 10);
                tab.classList.toggle('active', AppState.activeContextLevel === level);
            });
        }

        /**
         * Updates the textbox visual state based on screenshot toggle
         */
        function updateScreenshotVisual() {
            if (AppState.includeScreenshot) {
                chatInputBar.classList.add('with-screenshot');
            } else {
                chatInputBar.classList.remove('with-screenshot');
            }
        }

        function openTextbox() {
            document.body.classList.remove('input-hidden');
            document.body.classList.add('hover-enabled');  // Ensure hover enabled when opening
            updateScreenshotVisual(); // Apply saved state
            chatInput.focus();
        }

        function closeTextbox() {
            chatInput.blur();
        }

        // State 0 → State 1: Character just shown
        listen('shortcut-show-character', () => {
            AppState.shortcutState = 1;
            closeTextbox();
            // Enable hover after delay - prevents flicker if mouse already hovering
            setTimeout(() => {
                document.body.classList.remove('input-hidden');
                document.body.classList.add('hover-enabled');
            }, 200);
        });

        // State 1 → State 2 OR State 2 → State 0
        listen('shortcut-cycle-state', () => {
            const isFocused = document.activeElement === chatInput;

            if (!isFocused) {
                // State 1 → State 2: Focus input
                AppState.shortcutState = 2;
                openTextbox();
            } else {
                // State 2 → State 0: Hide character
                AppState.shortcutState = 0;
                document.body.classList.add('input-hidden');
                document.body.classList.remove('hover-enabled');  // Disable hover before hiding
                closeTextbox();
                invoke('hide_overlay');
            }
        });

        // Sync state on external visibility changes (e.g., tray menu)
        listen('overlay-visibility-changed', (event) => {
            if (!event.payload.visible) {
                AppState.shortcutState = 0;
                document.body.classList.add('input-hidden');
                document.body.classList.remove('hover-enabled');  // Disable hover when hiding
            } else if (AppState.shortcutState === 0) {
                AppState.shortcutState = 1;
                setTimeout(() => {
                    document.body.classList.remove('input-hidden');
                    document.body.classList.add('hover-enabled');  // Enable hover after delay
                }, 200);
            }
        });

        // Enhanced Markdown parser function
        function parseMarkdown(text) {
            // Escape HTML first
            let html = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');

            // Code blocks with language label
            html = html.replace(/```(\w*)\n([\s\S]*?)```/g, (_, lang, code) => {
                const langLabel = lang ? `<span class="code-lang">${lang}</span>` : '';
                return `<div class="code-block">${langLabel}<pre><code>${code.trim()}</code></pre></div>`;
            });

            // Inline code
            html = html.replace(/`([^`]+)`/g, '<code class="inline-code">$1</code>');

            // Headers (#### ### ## #)
            html = html.replace(/^#### (.*$)/gm, '<h5 class="md-h5">$1</h5>');
            html = html.replace(/^### (.*$)/gm, '<h4 class="md-h4">$1</h4>');
            html = html.replace(/^## (.*$)/gm, '<h3 class="md-h3">$1</h3>');
            html = html.replace(/^# (.*$)/gm, '<h2 class="md-h2">$1</h2>');

            // Horizontal rules
            html = html.replace(/^(---|\*\*\*|___)$/gm, '<hr class="md-hr">');

            // Blockquotes
            html = html.replace(/^&gt; (.*)$/gm, '<blockquote class="md-blockquote">$1</blockquote>');
            // Merge consecutive blockquotes
            html = html.replace(/<\/blockquote>\n<blockquote class="md-blockquote">/g, '<br>');

            // Links [text](url)
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" class="md-link" target="_blank" rel="noopener">$1</a>');

            // Bold (**text** or __text__)
            html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/__([^_]+)__/g, '<strong>$1</strong>');

            // Italic (*text* or _text_) - using word boundaries
            html = html.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<em>$1</em>');
            html = html.replace(/(?<!_)_([^_]+)_(?!_)/g, '<em>$1</em>');

            // Tables
            html = html.replace(/(?:^|\n)((?:\|[^\n]+\|\n)+)/g, (match, tableContent) => {
                const rows = tableContent.trim().split('\n');
                if (rows.length < 2) return match;

                // Check for separator row
                const sepIndex = rows.findIndex(r => /^\|[\s\-:|]+\|$/.test(r));
                if (sepIndex === -1) return match;

                let tableHtml = '<table class="md-table">';
                rows.forEach((row, i) => {
                    if (i === sepIndex) return; // Skip separator
                    const cells = row.split('|').filter(c => c.trim() !== '');
                    const tag = i < sepIndex ? 'th' : 'td';
                    tableHtml += '<tr>' + cells.map(c => `<${tag}>${c.trim()}</${tag}>`).join('') + '</tr>';
                });
                tableHtml += '</table>';
                return tableHtml;
            });

            // Lists with nesting support
            const lines = html.split('\n');
            let inList = false;
            let listItems = [];
            let orderedCounter = 0;
            let isOrdered = false;

            const processedLines = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const unorderedMatch = line.match(/^(\s*)([-*+]) (.+)$/);
                const orderedMatch = line.match(/^(\s*)(\d+)\. (.+)$/);

                if (unorderedMatch || orderedMatch) {
                    const match = unorderedMatch || orderedMatch;
                    const indent = match[1].length;
                    const level = Math.floor(indent / 2);
                    const content = unorderedMatch ? match[3] : match[3];

                    if (!inList) {
                        inList = true;
                        isOrdered = !!orderedMatch;
                        orderedCounter = 0;
                    }

                    orderedCounter++;
                    const attrs = isOrdered
                        ? `data-level="${level}" data-ordered="true" data-index="${orderedCounter}"`
                        : `data-level="${level}"`;
                    listItems.push(`<li class="md-li" ${attrs}>${content}</li>`);
                } else {
                    if (inList && listItems.length > 0) {
                        processedLines.push(`<ul class="md-list">${listItems.join('')}</ul>`);
                        listItems = [];
                        inList = false;
                        orderedCounter = 0;
                    }
                    processedLines.push(line);
                }
            }

            if (listItems.length > 0) {
                processedLines.push(`<ul class="md-list">${listItems.join('')}</ul>`);
            }

            html = processedLines.join('\n');

            // Paragraphs - wrap text blocks
            const parts = html.split(/\n\n+/);
            html = parts.map(p => {
                p = p.trim();
                if (!p) return '';
                if (p.startsWith('<h') || p.startsWith('<div class="code-block"') ||
                    p.startsWith('<ul') || p.startsWith('<ol') || p.startsWith('<table') ||
                    p.startsWith('<hr') || p.startsWith('<blockquote')) {
                    return p;
                }
                return `<p class="md-p">${p.replace(/\n/g, '<br>')}</p>`;
            }).join('');

            return html;
        }

        // Tab to toggle screenshot, Escape to dismiss, Enter to submit
        chatInput.addEventListener('keydown', async (e) => {
            if (e.key === 'Tab') {
                e.preventDefault();

                // Check if trying to enable screenshot
                if (!AppState.includeScreenshot) {
                    // Check if current model supports vision
                    const currentSupportsVision = AppState.activeContextLevel === 0
                        ? AppState.assistantSupportsVision
                        : AppState.rpSupportsVision;

                    if (!currentSupportsVision) {
                        updateStatus("Model doesn't support images", 'listening');
                        setTimeout(() => updateStatus('', ''), 2000);
                        return;
                    }
                }

                AppState.includeScreenshot = !AppState.includeScreenshot;
                localStorage.setItem('screenshotEnabled', AppState.includeScreenshot);
                updateScreenshotVisual();
                updateStatus(AppState.includeScreenshot ? '📷 Screenshot attached' : '📷 Screenshot disabled', 'listening');
                setTimeout(() => updateStatus('', ''), 1500);
            }
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                const isHistoryOpen = historyModal.classList.contains('visible');
                if (!isHistoryOpen) {
                    showHistoryModal();
                    AppState.historyFocusIndex = -1;
                } else {
                    navigateHistoryVertical('up');
                }
            }
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                const isHistoryOpen = historyModal.classList.contains('visible');
                if (isHistoryOpen) {
                    if (!navigateHistoryVertical('down')) {
                        hideHistoryModal();
                    }
                }
            }
            if (e.key === 'Escape') {
                const now = Date.now();
                const isHistoryOpen = historyModal.classList.contains('visible');
                const isInputFocused = document.activeElement === chatInput;

                if (isHistoryOpen) {
                    // Close history first
                    hideHistoryModal();
                } else if (isInputFocused) {
                    // Blur input
                    closeTextbox();
                    AppState.lastEscapeTime = now;
                } else if (now - AppState.lastEscapeTime < DOUBLE_TAP_THRESHOLD_MS) {
                    // Double escape: hide character
                    invoke('hide_overlay');
                    AppState.lastEscapeTime = 0;
                } else {
                    AppState.lastEscapeTime = now;
                }
            }
            // ArrowRight/Left for history navigation handled by window-level handler
            if (e.key === 'Enter') {
                const message = chatInput.value.trim();
                const isHistoryOpen = historyModal.classList.contains('visible');

                // Normal message send (only if there's a message)
                if (!message) return;

                const withScreenshot = AppState.includeScreenshot;
                const contextLevel = AppState.activeContextLevel;
                console.log('[Chat] Sending message:', message, 'screenshot:', withScreenshot, 'level:', contextLevel);
                chatInput.value = '';

                // Always open history view if not already open
                if (!isHistoryOpen) {
                    historyModal.classList.add('visible');
                    document.getElementById('historyBtn').classList.add('active');
                    updateLevelIndicator();
                }

                // Add user message to history immediately
                const userDiv = document.createElement('div');
                userDiv.className = 'history-message user';
                userDiv.textContent = message;
                userDiv.setAttribute('data-context-level', contextLevel);
                historyContent.appendChild(userDiv);

                // Track this user message for scroll limiting during streaming
                currentUserMessageElement = userDiv;

                // Scroll to bottom (force since user just sent a message)
                scrollHistoryToBottom(true);

                // Determine response role based on context level
                const responseRole = contextLevel === 1 ? 'character' : 'assistant';

                // Create streaming message div with thinking indicator
                const streamDiv = document.createElement('div');
                streamDiv.className = `history-message ${responseRole}`;
                streamDiv.id = 'streaming-message';
                streamDiv.setAttribute('data-context-level', contextLevel);
                streamDiv.innerHTML = 'Thinking<span class="thinking-indicator"><span class="dot">.</span><span class="dot">.</span><span class="dot">.</span></span>';
                historyContent.appendChild(streamDiv);

                // Track streaming content
                let assistantContent = '';

                scrollHistoryToBottom(true);

                // Set up stream listeners
                const unlistenChunk = await listen('chat-stream-chunk', (event) => {
                    const { chunk, role } = event.payload;

                    if (role === 'character' && contextLevel === 1) {
                        // Character DIALOGUE (level 1)
                        assistantContent += chunk;
                        const el = document.getElementById('streaming-message');
                        if (el) {
                            el.textContent = assistantContent;
                        }
                    } else if (role === 'assistant' && contextLevel === 0) {
                        // Assistant response (level 0)
                        assistantContent += chunk;
                        const el = document.getElementById('streaming-message');
                        if (el) {
                            el.innerHTML = parseMarkdown(assistantContent);
                        }
                    }
                    scrollHistoryToBottom();
                });

                const unlistenDone = await listen('chat-stream-done', async (event) => {
                    console.log('[Chat] Stream done:', event.payload);
                    // Clean up IDs
                    const streamEl = document.getElementById('streaming-message');
                    if (streamEl) streamEl.removeAttribute('id');
                });

                const unlistenError = await listen('chat-stream-error', (event) => {
                    console.error('[Chat] Stream error:', event.payload);
                    const el = document.getElementById('streaming-message');
                    if (el) {
                        el.textContent = 'Error: ' + event.payload.error;
                        el.style.color = '#f87171';
                    }
                });

                try {
                    // Invoke streaming command (returns when streaming completes)
                    await invoke('send_chat_message_stream', { message, includeScreenshot: withScreenshot, contextLevel });
                    console.log('[Chat] Streaming complete for level', contextLevel);
                } catch (error) {
                    console.error('[Chat] Error:', error);
                    const el = document.getElementById('streaming-message');
                    if (el) {
                        el.textContent = 'Error: ' + error;
                        el.style.color = '#f87171';
                    }
                } finally {
                    // Clean up listeners
                    unlistenChunk();
                    unlistenDone();
                    unlistenError();
                    // Clean up streaming IDs
                    const streamEl = document.getElementById('streaming-message');
                    if (streamEl) streamEl.removeAttribute('id');
                    // Clear the user message tracking so future scrolls work normally
                    currentUserMessageElement = null;
                }
            }
        });

        // Window-level keyboard handler for history (works even when input not focused)
        window.addEventListener('keydown', (e) => {
            const isHistoryOpen = historyModal.classList.contains('visible');
            if (!isHistoryOpen) return;

            // Don't interfere if typing in the input
            if (document.activeElement === chatInput && chatInput.value !== '') return;

            if (e.key === 'Escape') {
                e.preventDefault();
                hideHistoryModal();
                return;
            }

            if (e.key === 'ArrowUp') {
                e.preventDefault();
                navigateHistoryVertical('up');
            }

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (!navigateHistoryVertical('down')) {
                    hideHistoryModal();
                }
            }

            if (e.key === 'ArrowRight') {
                e.preventDefault();
                changeHistoryLevel('right');
            }

            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                changeHistoryLevel('left');
            }
        });

        // Click outside to blur input
        document.addEventListener('click', (e) => {
            if (!chatPanel.contains(e.target) &&
                document.activeElement === chatInput) {
                closeTextbox();
            }
        });

        // ============ Chat History ============
        async function loadChatHistory() {
            try {
                const history = await invoke('get_chat_history');
                historyContent.innerHTML = '';

                if (history.length === 0) {
                    historyContent.innerHTML = '<div class="history-empty">No chat history yet</div>';
                    return;
                }

                history.forEach(msg => {
                    const div = document.createElement('div');
                    div.className = `history-message ${msg.role}`;

                    // Store context level for filtering
                    div.setAttribute('data-context-level', msg.context_level || 0);

                    // Use markdown parsing for assistant messages, plain text for user/character
                    if (msg.role === 'assistant') {
                        div.innerHTML = parseMarkdown(msg.content);
                    } else {
                        div.textContent = msg.content;
                    }

                    historyContent.appendChild(div);
                });

                // Scroll to bottom (force since loading initial history)
                scrollHistoryToBottom(true);
            } catch (error) {
                console.error('[History] Failed to load:', error);
                historyContent.innerHTML = '<div class="history-empty">Failed to load history</div>';
            }
        }

        async function showHistoryModal() {
            historyModal.classList.add('visible');
            document.getElementById('historyBtn').classList.add('active');
            await loadChatHistory();
            updateLevelIndicator();
            applyHistoryFilter(); // Apply filter based on current level (0 on re-open)
            // Scroll to bottom after everything is loaded (force since opening modal)
            scrollHistoryToBottom(true);
            chatInput.focus();
        }

        function hideHistoryModal() {
            historyModal.classList.remove('visible');
            document.getElementById('historyBtn').classList.remove('active');
            AppState.historyFocusIndex = -1;
            historyContent.querySelectorAll('.focused').forEach(el => el.classList.remove('focused'));
            // Reset filter state of all messages
            historyContent.querySelectorAll('.history-message').forEach(msg => msg.classList.remove('filtered'));
            updateLevelIndicator();
            chatInput.placeholder = defaultPlaceholder;
            chatInput.disabled = false;
        }

        document.getElementById('closeHistoryBtn').onclick = () => {
            hideHistoryModal();
        };

        // Make history header draggable
        document.querySelector('.history-header').addEventListener('mousedown', async (e) => {
            // Don't drag if clicking on buttons or tabs
            if (e.target.closest('button') || e.target.closest('.chat-tab')) return;
            const win = getCurrentWindow();
            await win.startDragging();
        });

        // Tab click handlers - exclusive selection (not toggles)
        document.querySelectorAll('.chat-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const level = parseInt(tab.getAttribute('data-level'), 10);

                // Set active level (exclusive, not toggle)
                AppState.activeContextLevel = level;

                // Check if new model supports vision
                const newSupportsVision = level === 0
                    ? AppState.assistantSupportsVision
                    : AppState.rpSupportsVision;

                // If screenshot is enabled but new model doesn't support vision, disable it
                if (AppState.includeScreenshot && !newSupportsVision) {
                    AppState.includeScreenshot = false;
                    localStorage.setItem('screenshotEnabled', 'false');
                    updateStatus("Model doesn't support images - screenshot disabled", 'listening');
                    setTimeout(() => updateStatus('', ''), 2000);
                }

                AppState.historyFocusIndex = -1;
                loadChatHistory().then(() => {
                    applyHistoryFilter();
                    chatInput.focus();
                    updateScreenshotVisual();
                });
            });
        });

        // History button to open/close chat history
        document.getElementById('historyBtn').onclick = () => {
            const isVisible = historyModal.classList.contains('visible');
            if (isVisible) {
                hideHistoryModal();
            } else {
                showHistoryModal();
            }
        };

        // Listen for tray menu event to show history
        listen('show-chat-history', () => {
            showHistoryModal();
        });

        // Listen for model changes from settings
        listen('model-changed', (event) => {
            const { modelId, contextLevel, supportsVision } = event.payload;
            console.log('[Overlay] Model changed:', modelId, 'context:', contextLevel, 'vision:', supportsVision);

            // Update vision capability for the changed context level
            if (contextLevel === 0) {
                AppState.assistantSupportsVision = supportsVision;
            } else if (contextLevel === 1) {
                AppState.rpSupportsVision = supportsVision;
            }

            // If this is the current context level and screenshot is enabled but model doesn't support vision
            if (AppState.activeContextLevel === contextLevel && AppState.includeScreenshot && !supportsVision) {
                AppState.includeScreenshot = false;
                localStorage.setItem('screenshotEnabled', 'false');
                updateScreenshotVisual();
                updateStatus("Model doesn't support images - screenshot disabled", 'listening');
                setTimeout(() => updateStatus('', ''), 2000);
            }
        });

        // Initialize vision capability on load
        async function initVisionCapability() {
            try {
                const config = await invoke('get_llm_config_cmd');
                const assistantVision = await invoke('get_model_supports_vision', { modelId: config.assistant_model });
                const rpVision = await invoke('get_model_supports_vision', { modelId: config.rp_model });

                AppState.assistantSupportsVision = assistantVision;
                AppState.rpSupportsVision = rpVision;

                console.log('[Overlay] Vision capability initialized - Assistant:', assistantVision, 'RP:', rpVision);

                // Check if current model doesn't support vision and screenshot is enabled
                const currentSupportsVision = AppState.activeContextLevel === 0 ? assistantVision : rpVision;
                if (AppState.includeScreenshot && !currentSupportsVision) {
                    AppState.includeScreenshot = false;
                    localStorage.setItem('screenshotEnabled', 'false');
                    updateScreenshotVisual();
                }
            } catch (err) {
                console.error('[Overlay] Failed to init vision capability:', err);
            }
        }

        // Call init after a short delay to ensure everything is loaded
        setTimeout(initVisionCapability, 500);

        // ============ UI Helpers ============
        function updateStatus(text, className) {
            const indicator = document.getElementById('statusIndicator');
            indicator.textContent = text;
            indicator.className = 'status-indicator ' + className;
        }

        // ============ Idle Animation ============
        let breathePhase = 0;
        setInterval(() => {
            if (live2dOverlay.model) {
                breathePhase += 0.02;
                const breathe = Math.sin(breathePhase) * 0.02;
                live2dOverlay.setParameter('ParamBreath', 0.5 + breathe * 10);

                if (Math.random() < 0.002) {
                    triggerBlink();
                }
            }
        }, 16);

        function triggerBlink() {
            const blinkDuration = 150;
            const startTime = Date.now();

            function blinkFrame() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / blinkDuration;

                if (progress < 0.5) {
                    const eyeOpen = 1 - (progress * 2);
                    live2dOverlay.setParameter('ParamEyeLOpen', eyeOpen);
                    live2dOverlay.setParameter('ParamEyeROpen', eyeOpen);
                } else if (progress < 1) {
                    const eyeOpen = (progress - 0.5) * 2;
                    live2dOverlay.setParameter('ParamEyeLOpen', eyeOpen);
                    live2dOverlay.setParameter('ParamEyeROpen', eyeOpen);
                } else {
                    live2dOverlay.setParameter('ParamEyeLOpen', 1);
                    live2dOverlay.setParameter('ParamEyeROpen', 1);
                    return;
                }
                requestAnimationFrame(blinkFrame);
            }
            blinkFrame();
        }

        // Listen for reload-character event to hot-reload textures
        listen('reload-character', () => {
            frontendLog('info', '[Overlay] Reload character event received - reloading model');
            autoLoadModel();
        });

        // Listen for init-complete event from main window (for first-launch after download)
        listen('init-complete', () => {
            frontendLog('info', '[Overlay] Init complete - loading model');
            autoLoadModel();
        });

        // Initialize
        window.addEventListener('DOMContentLoaded', async () => {
            live2dOverlay.initApp();
            updateTooltips();
            resizeHitboxCanvas();

            // Check if model is already downloaded before attempting to load
            // On first launch, model may not exist yet - init-complete will trigger load later
            try {
                const initialized = await invoke('is_initialized');
                if (initialized) {
                    frontendLog('info', '[Overlay] Ready - model exists, auto-loading');
                    autoLoadModel();
                } else {
                    frontendLog('info', '[Overlay] Ready - waiting for model download (init-complete)');
                }
            } catch (err) {
                frontendLog('error', '[Overlay] Failed to check initialization: ' + err);
            }
        });

    </script>
</body>
</html>
